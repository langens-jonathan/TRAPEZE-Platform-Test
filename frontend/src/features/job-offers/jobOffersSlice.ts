import {createAsyncThunk, createSlice} from '@reduxjs/toolkit';
import JobOffer from "../../models/JobOffer";
import { getJobOffers as getJobOffersAPI } from "./JobOffersAPI";
import { RootState } from "../../app/store";
import { PayloadAction } from "@reduxjs/toolkit/dist/createAction";

export interface JobOffersState {
    isLoading: boolean
    errorMessage: string
    filter: string
    offset: number
    limit: number
    hasMore: boolean
    sortOn: "relevance" | "title" | "createdOn"
    jobOffers: JobOffer[]
}

const initialState: JobOffersState = {
    isLoading: false,
    errorMessage: "",
    filter: "",
    offset: 0,
    limit: 12,
    hasMore: false,
    sortOn: "createdOn",
    jobOffers: []
};

export const getJobOffers = createAsyncThunk<JobOffer[], { filter: string, offset: number, limit: number }, { rejectValue: string }>(
  'job-offers/getJobOffers',
  async (payload: { filter: string, offset: number, limit: number }, { getState, rejectWithValue }) => {
      try {
          const state = getState() as RootState;
          const { filter, offset, limit } = state.jobOffers;
          return await getJobOffersAPI(filter, offset, limit + 1) as JobOffer[];
      }
      catch(e) {
          return rejectWithValue(e?.message)
      }
  }
);

export const jobOffersSlice = createSlice({
    name: "job-offers",
    initialState,
    reducers: {
        setFilter(state, action: PayloadAction<string>){
            state.filter = action.payload;
            state.jobOffers = [];
            state.offset = 0;
        },
        setOffset(state, action: PayloadAction<number>){
            state.offset = action.payload;
        },
        setLimit(state, action: PayloadAction<number>){
            state.limit = action.payload;
        },
        setSortOn(state, action: PayloadAction<"relevance" | "title" | "createdOn">){
            state.sortOn = action.payload;
        }
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
          .addCase(getJobOffers.pending, (state) => {
              state.isLoading = true;
              state.errorMessage = "";
          })
          .addCase(getJobOffers.fulfilled, (state, action) => {
              state.isLoading = false;
              let jobOffers = action.payload;
              state.hasMore = false;
              if(action.payload.length > state.limit) {
                  jobOffers = jobOffers.slice(0, state.limit);
                  state.hasMore = true;
              }
              const map = new Map<string, JobOffer>();
              [...state.jobOffers, ...jobOffers].forEach((jobOffer) => map.set(jobOffer.id, jobOffer));
              state.jobOffers = Array.from(map.values());
          })
          .addCase(getJobOffers.rejected, (state, action) => {
              state.isLoading = false;
              state.jobOffers = [];
              state.errorMessage = action.payload || "An error occurred when trying to fetch job offers.";
          })
    },
});

export const { setFilter, setOffset, setLimit, setSortOn } = jobOffersSlice.actions;

export default jobOffersSlice.reducer;
